### 2022-4-25

[LeetCode链接](https://leetcode-cn.com/problems/container-with-most-water/)
#### 题目名：盛水最多的容器
#### 方法：双指针或暴力解法（超时）
#### 整体思路
- 第一种思路：首先最容易想到的就是暴力解法，即枚举所有可能的情况,但是没有卵用，后面的测试样例根本过不了！
- 第二种思路：双指针
1.  我们可以看到制约盛水面积的主要因素是**受限于最短的边**，类似于**木桶效应**
2. 所以定义左指针left，以及右指针right，分别向中间移动，当left指针对应的线的高度比right指针所对应的线的高度小的时候，说明盛水面积受限于左边高度left，那么就改变left指针的值。left++向右边移动，反之的话right- -向左边移动。
3. 具体实现见代码

#### 代码实现

```javascript
//  解法1：暴力
const maxArea= (height) => {
	// 数组长度为2就直接返回
    if(height.length===2) return Math.min(height[0],height[1])
    //用于存放最大的面积
    let max = 0
    for(let i =0;i < height.length-1;i++) {
        for (let j = i+1;j<height.length;j++) {
            let temp = (j-i)*Math.min(height[i],height[j])
            max = Math.max(max,temp)
        }
    }
    return max
}
// 解法2：双指针
    if(height.length===2) return Math.min(height[0],height[1])
    let left = 0
    let right = height.length-1
    let max = 0
    while(left<right) {
        max =Math.max(max,Math.min(height[left],height[right])*(right-left))
        if(height[left]<height[right]) {
            left++
        }else {
            right--
        }
    }
    return max
```
#### 题目名：三数之和
[LeetCode链接](https://leetcode-cn.com/problems/3sum/)

#### 方法：枚举+双指针或暴力解法（超时）
#### 整体思路
- 第一种思路：首先最容易想到的就是暴力解法，即枚举所有可能的情况,但是没有卵用，时间复杂度为on3所以直接G。
- 第二种思路：枚举+双指针
1.  每枚举一个数，就定义双指针枚举剩下的数，看能不能凑到三个数的和等于0，因为双指针每个指针指向一个数，加上枚举的这个数正好三个。
2. 所以定义左指针j，以及右指针k，分别向中间移动，遇到相同的元素就跳过，根据三个数的和与0的数进行比较，判断哪个指针进行移动，先看代码再回来看思路分析更好理解。
3. 注释写的比较详细，具体实现见代码

#### 代码实现
```javascript
//  解法1：暴力
// 暴力解这边不展示了~
//  解法2：枚举+双指针
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
const threeSum = function(nums) {
		// 数据长度小于3直接返回
    	if(nums.length<3) return []
        let n = nums.length
        // 定义出结果数组
        let resArr = []
        nums.sort((a,b) => a-b)
        // 排序之后最小数大于0，最大数小于0直接返回
        if(nums[0]>0 || nums[n-1]<0) {
            return []
        }
        //开始枚举，注意边界条件，最后一个枚举的数为倒数第三个
        for(let i = 0;i<n-2;i++) {
            // 枚举的时候跳过相同的数
            if(i && nums[i] === nums[i-1]) {
                continue
            }
            // 如果枚举的这个数比0大说明继续枚举还是比0大，找不到结果直接返回
            if(nums[i]>0) {
                break
            }
            // 定义左右指针
            j = i+1
            k = n-1
            while(j<k) {
            //	计算现在的三个数值
                let tar = nums[i] + nums[j] + nums[k]
                // 如果比0大了说明需要小的数，右指针减小
                if(tar> 0) {
                    k--
                }else if(tar < 0) {
                    j++
                }else {
                // 找到了合适的结果，创建新数组push进结果数组
                    resArr.push([nums[i],nums[j],nums[k]])
                    // 两个指针同时向中间移动
                    k--
                    j++
                    // 用来判断指针指向的元素是否重复
                    while(j<k&&nums[k]===nums[k+1]) k--
                    while(j<k&&nums[j]===nums[j-1]) j++
                }
            }
        }
        return resArr
};
```
#### 题目名：电话号码的字母组合
[LeetCode链接](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

#### 方法：枚举所有可能情况
#### 整体思路
- 循环digits字符串，根据对应的字符串的值找到letters字符数组中的值。
- 第一次循环得到初始字母数组比如['a','b','c'],第二次的字符比如是['d','e','f']就遍历后边的字符数组并拼接，然后拼接好的从新赋值用于下次拼接。

#### 代码实现
```javascript
    /**
 * @param {string} digits
 * @return {string[]}
 */
const letterCombinations = function(digits) {
    let letters = [
        [],
        [],
        ['a','b','c'],
        ['d','e','f'],
        ['g','h','i'],
        ['j','k','l'],
        ['m','n','o'],
        ['p','q','r','s'],
        ['t','u','v'],
        ['w','x','y','z']
    ]
    let res = []
    for (let i =0;i<digits.length;i++) {
        let arr = []
        if(i===0) {
        // 用于拼接的初始数组
            res = [...letters[digits[i]]]
            continue
        }else {
        // 遍历遇到的后边的字符数组
            for(let j = 0,l = letters[digits[i]].length;j<l;j++) {
                let temp = letters[digits[i]][j]
                res.forEach(item => {
                    arr.push(item +temp)
                })
            }
            // 将拼接好的字符赋值给res用于后边的拼接，当digits遍历完之后也就拼接结束。
            res = arr
        }
    }
    return res
};
```

### 2022-4-26 

#### 题目名：立体投影的面积
[LeetCode链接](https://leetcode-cn.com/problems/projection-area-of-3d-shapes/submissions/)

#### 方法：直接模拟
#### 整体思路
- z方向的面积为矩阵元素不为0的个数
- y方向为每一行的最大值相加
- x方向为每一列的最大值相加
#### 代码实现
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
const projectionArea = function(grid) {
    let n = grid.length
    //z方向的面积就是不为0的元素的个数，需要统计二维数组中不为0的元素个数
    let count = 0
    let yArea = 0
    let xArea = 0
    let temp = 0
    for (let i = 0; i < n; i++) {
        // 求y方向上数组的最大值并不断相加
        yArea += Math.max(...grid[i])
    }
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < grid[i].length; j++) {
            temp = Math.max(grid[j][i],temp)
            if(grid[i][j]!==0) {
                count++
            }
        }
        xArea+=temp
        temp = 0
    }
    return count+yArea+xArea
};
```

#### 题目名：括号生成
[LeetCode链接](https://leetcode-cn.com/problems/generate-parentheses/)

#### 方法：任意位置插入+set去重
#### 整体思路
- 在括号的任意位置插入括号，然后利用set集合将重复的括号去除
#### 代码实现
```javascript
/**
 * @param {number} n
 * @return {string[]}
 */
const generateParenthesis = function(n) {
        let set = new Set(['()'])
        // 从第二个开始插入
        for (let i = 2; i <= n; i++) {
            // 初始化中间变量
            let nextSet = new Set()
            // 遍历set
            for (const s of set) {
                // console.log(s)
                for (let j = 0; j <s.length; j++) {
                    // 将括号插入到任意的位置
                    nextSet.add(s.slice(0,j)+'()'+s.slice(j))
                }
            }
            set = nextSet
        }
        // 返回浅拷贝的数组实例，还可以写成扩展运算符[...set]
        return Array.from(set)
    };
```

#### 题目名：合并k个升序链表
[LeetCode链接](https://leetcode-cn.com/problems/merge-k-sorted-lists)
#### 方法：两两合并
#### 整体思路
- 利用合并两个有序链表，将其写成方法，然后将k个链表两个两个进行合并，最终返回的就是k个升序链表，但是效率比较低。
#### 代码实现
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
const mergeKLists = function(lists) {
    // if(lists.length===0) return null
    // if(lists.length===1) return lists[0]
    // 合并两个链表的方法
    const mergeTwo = (list1,list2) => {
        // if (list1 === null && list2 === null) {
        //     return null
        // }
        if (list1 === null || list2 === null) {
            return list1 === null ? list2 : list1
        }
        let newHead = new ListNode(0)
        let temp = newHead
        while (list1 !== null && list2 !== null) {
            if (list1.val>=list2.val) {
                temp.next = list2
                // newHead = newHead.next
                list2 = list2.next
            }else {
                temp.next = list1
                // newHead = list1
                // newHead = newHead.next
                list1 = list1.next
            }
            temp = temp.next
        }
        temp.next = list1 === null? list2 : list1
        return newHead.next
    }
    let newHead =  new ListNode(-Infinity)
    let temp = newHead
    // 迭代合并两个链表
    for(let i = 0;i<lists.length;i++) {
        temp = mergeTwo(lists[i],temp)
    }
    return newHead.next
    // return mergeTwo(lists.pop(),mergeKLists(lists))
};
```
### 2022-4-29
#### 题目名：建立四叉树
[LeetCode链接](https://leetcode-cn.com/problems/construct-quad-tree/)
#### 方法：dfs+递归
#### 整体思路
- 首先可以发现每个矩形框框都在做重复的事情只是范围不太一样，当一个矩形框的内容都一致的时候就可返回一个叶子节点。
- 当有不一样的情况说明这不是叶子节点需要向里边递归

#### 代码实现
```javascript
/**
 * // Definition for a QuadTree node.
 * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {
 *    this.val = val;
 *    this.isLeaf = isLeaf;
 *    this.topLeft = topLeft;
 *    this.topRight = topRight;
 *    this.bottomLeft = bottomLeft;
 *    this.bottomRight = bottomRight;
 * };
 */

/**
 * @param {number[][]} grid
 * @return {Node}
 */
const construct = function(grid) {
    function dfs(grid,x0,y0,x1,y1){
        for(let i = x0;i<x1;i++) {
            for(let j = y0;j<y1;j++) {
                if(grid[x0][y0]!==grid[i][j]){
                    return new Node(1,false,
                    dfs(grid,x0,y0,(x0+x1)/2,(y0+y1)/2),
                    dfs(grid,x0,(y0+y1)/2,(x0+x1)/2,y1),
                    dfs(grid,(x0+x1)/2,y0,x1,(y0+y1)/2),
                    dfs(grid,(x0+x1)/2,(y0+y1)/2,x1,y1))
                }
            }
        }
        console.log(x0,y0)
        // let node = new Node()
        return new Node(grid[x0][y0],true)
    }
    let n = grid.length
    return dfs(grid,0,0,n,n)
};
```

#### 题目名： 寻找旋转排序数组中的最小值
[LeetCode链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)
#### 方法：二分查找
#### 整体思路
- 当中间值小于右边界的时候就一直舍弃右边界
- 否则就舍弃左边界

#### 代码实现
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
const findMin = function(nums) {
    if(nums[0]<nums[nums.length-1]) return nums[0]
    if(nums.length===1) return nums[0]
    let left = 0
    let right = nums.length -1
    while(left<right) {

        let mid = left + Math.floor((right-left)/2)
        if(nums[mid]<nums[right]) {
            right = mid
        }else {
            left = mid + 1
        }
    }
    return nums[left]
};
```

#### 题目名：寻找峰值
[LeetCode链接](https://leetcode-cn.com/problems/find-peak-element/)
#### 方法：暴力查找
#### 整体思路
- 可以查找到题目的最大值最大值一定就是峰值，返回最大值的索引就可以了
#### 代码实现
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
const findPeakElement = function(nums) {
    if(nums.length===1 || nums[0]>nums[1]) return 0
    if(nums[nums.length-1]>nums[nums.length-2]) return nums.length-1
    let max = -Infinity
    let index = 0
    for(let i = 0;i<nums.length;i++) {
        if(max<nums[i]) {
            max = nums[i]
            index = i
        }
    }
    return index
};
```
### 2022-4-30
#### 题目名：最小差值Ⅰ
[LeetCode链接](https://leetcode-cn.com/problems/smallest-range-i/)
#### 方法：脑筋急转弯
#### 整体思路
- 当数组的最大值与最小值之差小于等于两倍所给的数字的时候就一定可以将两个数字变换到一样多的数值直接返回0
- 假如最大值最小值之差大于2k则说明不能返回0，制约两个数最小的原因在于最小值与最大值的差距，所以可以将最小值+k，最大值-k然后返回两数的差即可
#### 代码实现
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var smallestRangeI = function(nums, k) {
        nums.sort((a, b) => a - b)
        if (k >= nums[nums.length - 1] || nums.length === 1) return 0
        let temp = nums[nums.length - 1] - nums[0]
        if (temp <= 2 * k) {
            return 0
        } else {
            nums[nums.length - 1] -= k
            nums[0] += k
            return nums[nums.length - 1] - nums[0]
        }
};
```
#### 题目名：删除排序链表中的重复元素 II
[LeetCode链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)
#### 方法：set集合或者直接模拟
#### 整体思路
- set集合存入重复或者直接模拟
#### 代码实现
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * 
 * 方法1：直接模拟
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function (head) {
    let newHead = new ListNode(0, head)
    cur = newHead
    while (cur.next && cur.next.next) {
        if (cur.next.val === cur.next.next.val) {
            const x = cur.next.val
            /**
             * 注意判断条件的顺序，逻辑上是判断先有没有cur.next在获取cur.next的数值，不然会报错。
             */
            while (cur.next && cur.next.val === x) {
                cur.next = cur.next.next
            }
        } else {
            cur = cur.next
        }
    }
    return newHead.next
};
/**
 * 方法2 ：两次遍历先把重复数值存入set集合，在遍历把重复的忽略
 * @param head
 * @returns {*}
 */
var deleteDuplicates = function(head) {
    let node = new ListNode(999)
    node.next = head
    let cur = node
    let set = new Set()
    while(cur && cur.next){
        if (cur.val === cur.next.val){
            set.add(cur.val)
            cur.next = cur.next.next
        } else {
            cur = cur.next
        }
    }
    cur = node
    while(cur && cur.next){
        if (set.has(cur.next.val)){
            cur.next = cur.next.next
        } else {
            cur = cur.next
        }
    }
    return node.next
};
```
#### 题目名：三数之和
[LeetCode链接](https://leetcode-cn.com/problems/3sum/)
#### 方法：参考之前笔记，这次写的暴力
#### 整体思路
- 暴力枚举
#### 代码实现
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
        if (nums.length < 3) return []
        nums.sort((a, b) => a - b)
        let res = []
        for (let i = 0; i < nums.length; i++) {
            if (i && nums[i] === nums[i - 1]) {
                continue
            }
            for (let j = i + 1; j < nums.length; j++) {
                if (j > i + 1 && nums[j] === nums[j - 1]) {
                    continue
                }
                for (let k = j + 1; k < nums.length; k++) {
                    if (k > j + 1 && nums[k] === nums[k - 1]) {
                        continue
                    }
                    if (nums[i] + nums[j] + nums[k] === 0) {
                        res.push([nums[i], nums[j], nums[k]])

                    }

                }
            }
        }
        return res
};
```
