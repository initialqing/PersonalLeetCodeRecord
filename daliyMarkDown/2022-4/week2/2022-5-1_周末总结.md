> 2022-4-25 LeetCode热题100(hot100) 每日题目第二周    &nbsp;&nbsp;&nbsp;&nbsp;周一

[LeetCode链接](https://leetcode-cn.com/problems/container-with-most-water/)
#### 题目名：盛水最多的容器
#### 方法：双指针或暴力解法（超时）
#### 整体思路
- 第一种思路：首先最容易想到的就是暴力解法，即枚举所有可能的情况,但是没有卵用，后面的测试样例根本过不了！
- 第二种思路：双指针
1.  我们可以看到制约盛水面积的主要因素是**受限于最短的边**，类似于**木桶效应**
2. 所以定义左指针left，以及右指针right，分别向中间移动，当left指针对应的线的高度比right指针所对应的线的高度小的时候，说明盛水面积受限于左边高度left，那么就改变left指针的值。left++向右边移动，反之的话right- -向左边移动。
3. 具体实现见代码

#### 代码实现

```javascript
//  解法1：暴力
const maxArea= (height) => {
	// 数组长度为2就直接返回
    if(height.length===2) return Math.min(height[0],height[1])
    //用于存放最大的面积
    let max = 0
    for(let i =0;i < height.length-1;i++) {
        for (let j = i+1;j<height.length;j++) {
            let temp = (j-i)*Math.min(height[i],height[j])
            max = Math.max(max,temp)
        }
    }
    return max
}
// 解法2：双指针
    if(height.length===2) return Math.min(height[0],height[1])
    let left = 0
    let right = height.length-1
    let max = 0
    while(left<right) {
        max =Math.max(max,Math.min(height[left],height[right])*(right-left))
        if(height[left]<height[right]) {
            left++
        }else {
            right--
        }
    }
    return max
```
#### 题目名：三数之和
[LeetCode链接](https://leetcode-cn.com/problems/3sum/)

#### 方法：枚举+双指针或暴力解法（超时）
#### 整体思路
- 第一种思路：首先最容易想到的就是暴力解法，即枚举所有可能的情况,但是没有卵用，时间复杂度为on3所以直接G。
- 第二种思路：枚举+双指针
1.  每枚举一个数，就定义双指针枚举剩下的数，看能不能凑到三个数的和等于0，因为双指针每个指针指向一个数，加上枚举的这个数正好三个。
2. 所以定义左指针j，以及右指针k，分别向中间移动，遇到相同的元素就跳过，根据三个数的和与0的数进行比较，判断哪个指针进行移动，先看代码再回来看思路分析更好理解。
3. 注释写的比较详细，具体实现见代码

#### 代码实现
```javascript
//  解法1：暴力
// 暴力解这边不展示了~
//  解法2：枚举+双指针
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
const threeSum = function(nums) {
		// 数据长度小于3直接返回
    	if(nums.length<3) return []
        let n = nums.length
        // 定义出结果数组
        let resArr = []
        nums.sort((a,b) => a-b)
        // 排序之后最小数大于0，最大数小于0直接返回
        if(nums[0]>0 || nums[n-1]<0) {
            return []
        }
        //开始枚举，注意边界条件，最后一个枚举的数为倒数第三个
        for(let i = 0;i<n-2;i++) {
            // 枚举的时候跳过相同的数
            if(i && nums[i] === nums[i-1]) {
                continue
            }
            // 如果枚举的这个数比0大说明继续枚举还是比0大，找不到结果直接返回
            if(nums[i]>0) {
                break
            }
            // 定义左右指针
            j = i+1
            k = n-1
            while(j<k) {
            //	计算现在的三个数值
                let tar = nums[i] + nums[j] + nums[k]
                // 如果比0大了说明需要小的数，右指针减小
                if(tar> 0) {
                    k--
                }else if(tar < 0) {
                    j++
                }else {
                // 找到了合适的结果，创建新数组push进结果数组
                    resArr.push([nums[i],nums[j],nums[k]])
                    // 两个指针同时向中间移动
                    k--
                    j++
                    // 用来判断指针指向的元素是否重复
                    while(j<k&&nums[k]===nums[k+1]) k--
                    while(j<k&&nums[j]===nums[j-1]) j++
                }
            }
        }
        return resArr
};
```
#### 题目名：电话号码的字母组合
[LeetCode链接](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

#### 方法：枚举所有可能情况
#### 整体思路
- 循环digits字符串，根据对应的字符串的值找到letters字符数组中的值。
- 第一次循环得到初始字母数组比如['a','b','c'],第二次的字符比如是['d','e','f']就遍历后边的字符数组并拼接，然后拼接好的从新赋值用于下次拼接。

#### 代码实现
```javascript
    /**
 * @param {string} digits
 * @return {string[]}
 */
const letterCombinations = function(digits) {
    let letters = [
        [],
        [],
        ['a','b','c'],
        ['d','e','f'],
        ['g','h','i'],
        ['j','k','l'],
        ['m','n','o'],
        ['p','q','r','s'],
        ['t','u','v'],
        ['w','x','y','z']
    ]
    let res = []
    for (let i =0;i<digits.length;i++) {
        let arr = []
        if(i===0) {
        // 用于拼接的初始数组
            res = [...letters[digits[i]]]
            continue
        }else {
        // 遍历遇到的后边的字符数组
            for(let j = 0,l = letters[digits[i]].length;j<l;j++) {
                let temp = letters[digits[i]][j]
                res.forEach(item => {
                    arr.push(item +temp)
                })
            }
            // 将拼接好的字符赋值给res用于后边的拼接，当digits遍历完之后也就拼接结束。
            res = arr
        }
    }
    return res
};
```

> 2022-4-26 LeetCode热题100(hot100) 每日题目第二周    &nbsp;&nbsp;&nbsp;&nbsp;周二

#### 题目名：立体投影的面积
[LeetCode链接](https://leetcode-cn.com/problems/projection-area-of-3d-shapes/submissions/)

#### 方法：直接模拟
#### 整体思路
- z方向的面积为矩阵元素不为0的个数
- y方向为每一行的最大值相加
- x方向为每一列的最大值相加
#### 代码实现
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
const projectionArea = function(grid) {
    let n = grid.length
    //z方向的面积就是不为0的元素的个数，需要统计二维数组中不为0的元素个数
    let count = 0
    let yArea = 0
    let xArea = 0
    let temp = 0
    for (let i = 0; i < n; i++) {
        // 求y方向上数组的最大值并不断相加
        yArea += Math.max(...grid[i])
    }
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < grid[i].length; j++) {
            temp = Math.max(grid[j][i],temp)
            if(grid[i][j]!==0) {
                count++
            }
        }
        xArea+=temp
        temp = 0
    }
    return count+yArea+xArea
};
```

#### 题目名：括号生成
[LeetCode链接](https://leetcode-cn.com/problems/generate-parentheses/)

#### 方法：任意位置插入+set去重
#### 整体思路
- 在括号的任意位置插入括号，然后利用set集合将重复的括号去除
#### 代码实现
```javascript
/**
 * @param {number} n
 * @return {string[]}
 */
const generateParenthesis = function(n) {
        let set = new Set(['()'])
        // 从第二个开始插入
        for (let i = 2; i <= n; i++) {
            // 初始化中间变量
            let nextSet = new Set()
            // 遍历set
            for (const s of set) {
                // console.log(s)
                for (let j = 0; j <s.length; j++) {
                    // 将括号插入到任意的位置
                    nextSet.add(s.slice(0,j)+'()'+s.slice(j))
                }
            }
            set = nextSet
        }
        // 返回浅拷贝的数组实例，还可以写成扩展运算符[...set]
        return Array.from(set)
    };
```

#### 题目名：合并k个升序链表
[LeetCode链接](https://leetcode-cn.com/problems/merge-k-sorted-lists)
#### 方法：两两合并
#### 整体思路
- 利用合并两个有序链表，将其写成方法，然后将k个链表两个两个进行合并，最终返回的就是k个升序链表，但是效率比较低。
#### 代码实现
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
const mergeKLists = function(lists) {
    // if(lists.length===0) return null
    // if(lists.length===1) return lists[0]
    // 合并两个链表的方法
    const mergeTwo = (list1,list2) => {
        // if (list1 === null && list2 === null) {
        //     return null
        // }
        if (list1 === null || list2 === null) {
            return list1 === null ? list2 : list1
        }
        let newHead = new ListNode(0)
        let temp = newHead
        while (list1 !== null && list2 !== null) {
            if (list1.val>=list2.val) {
                temp.next = list2
                // newHead = newHead.next
                list2 = list2.next
            }else {
                temp.next = list1
                // newHead = list1
                // newHead = newHead.next
                list1 = list1.next
            }
            temp = temp.next
        }
        temp.next = list1 === null? list2 : list1
        return newHead.next
    }
    let newHead =  new ListNode(-Infinity)
    let temp = newHead
    // 迭代合并两个链表
    for(let i = 0;i<lists.length;i++) {
        temp = mergeTwo(lists[i],temp)
    }
    return newHead.next
    // return mergeTwo(lists.pop(),mergeKLists(lists))
};
```
> 2022-4-27 LeetCode热题100(hot100) 每日题目第二周    &nbsp;&nbsp;&nbsp;&nbsp;周三

#### 题目1：下一个排列
[LeetCode链接](https://leetcode-cn.com/problems/next-permutation/)
#### 方法：找规律
#### 思路:
- 第一步：从后往前找；看有没有下坡（前一个数比后一个数小的） 如果没有直接排序后返回；
- 第二步：如果有就说明有更小的排列 记住小的位置的索引设为index；再从后往前找比index位置的值大的索引；然后交换值；
- 第三步：index后的值从小到大排序；
#### 代码实现
```javascript

/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
const nextPermutation = function (nums) {
    let tempIndex = 0
    let flag = false
    for (let index = nums.length-1; index >=1; index--) {
        if(nums[index]>nums[index-1]) {
            flag = true
            tempIndex = index-1
            break
        }
    }
    if(!flag) return nums.sort((a,b) => a-b)
    for (let index = nums.length-1; index >=0; index--) {
        if (nums[index]>nums[tempIndex]) {
            // 交换数组中两个元素的值可以使用es6的语法
            // [arr[left],arr[right]] = [arr[right],arr[left]]
            let temp = nums[index]
            nums[index] = nums[tempIndex]
            nums[tempIndex] = temp
            break
        }
    }
    // tempIndex后边的数组需要升序排列
    let left = tempIndex+1
    let right = nums.length-1
    while(left<right) {
        // 先交换后移动
        [nums[left],nums[right]] = [nums[right],nums[left]]
        right--
        left++
    }
};
```

#### 题目2：太平洋和大西洋的水流问题

[LeetCode](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

#### 方法：DFS
#### 思路：
前情提要：
1. 定义两个dfs队列，也就是遍历的坐标，包括太平洋和大西洋
2. 定义两个二维数组，包括太平洋和大西洋，假如符合要求就在相应的坐标位置置true
3. 最终返回的结果是两个二维数组中都为true的部分坐标

- 假定水从大西洋或者太平洋从低的地方向高的地方流动，从海洋的边缘向内部流动，遇到比当前海拔高的单元格就记录单元格并进入
- 最终遍历完所有可能的结果之后同时取两个数组中结果都为true的就说明可以从这个点既流入大西洋也流入太平洋
#### 代码实现：
```javascript
/**
 * @param {number[][]} heights
 * @return {number[][]}
 */
const pacificAtlantic = function(heights) {
    let pacificQueue = []
    let atlanticQueue = []
    // 得到行数列数创建后边的数组
    let row = heights.length,col = heights[0].length
    // 创建移动坐标
    let directions = [
        [0,1],
        [0,-1],
        [1,0],
        [-1,0]
    ]
    // 存放访问过太平洋坐标
    let pacificVisited = new Array(row)
    .fill(false)
    .map( () => new Array(col).fill(false))
    let atlanticVisited = new Array(row)
    .fill(false)
    .map(() => new Array(col).fill(false))
    for(let i = 0;i<row;i++) {
        // 最左边的一列，需要遍历行
        pacificQueue.push([i,0])
        pacificVisited[i][0] = true;
        // 最右边一列
        atlanticQueue.push([i,col-1])
        atlanticVisited[i][col - 1] = true;
    }
    for(let i = 0;i<col;i++) {
        // 最上边一行
        pacificQueue.push([0,i])
        pacificVisited[0][i] = true
        // 最下边一行
        atlanticQueue.push([row-1,i])
        atlanticVisited[row-1][i] = true

    }
    const bfs = (queue,visitArray) => {
        while(queue.length) {
        let [x,y] = queue.shift()
        for(const dir of directions) {
            let curx = x + dir[0]
            let cury = y + dir[1]
            if(
                curx>=0 
                && cury>=0 
                && curx < row 
                && cury < col 
                && !visitArray[curx][cury] 
                && heights[curx][cury] >= heights[x][y]
            ){
                queue.push([curx,cury])
                visitArray[curx][cury] = true
            }
        }
    }
    return visitArray
    }
    pacificVisited = bfs(pacificQueue,pacificVisited)
    atlanticVisited = bfs(atlanticQueue,atlanticVisited)
    let res = []
    for(let i = 0;i<row;i++){
        for(let j=0;j<col;j++) {
            if(pacificVisited[i][j] && atlanticVisited[i][j]) res.push([i,j])
        }
    }
    return res
};
```

#### 题目3：搜索旋转排序数组
[LeetCode](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
#### 方法：二分查找
#### 思路：
对于有序数组，可以使用二分查找的方法查找元素。

但是这道题中，数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分查找吗？答案是可以的。

可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，
我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。

这启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：

#### 代码实现
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
const search = function(nums, target) {
  if (!nums.length) return -1
  let left = 0
  let right = nums.length - 1
  let mid
  while (left <= right) {
      // >> 1 位运算代替 除2 取整 操作
      // 为什么不写成 mid = (left+right)/2 ,因为考虑到left+right的溢出边界情况
      mid = left + Math.floor((right-left)/2)
      if(nums[mid]===target) {
          return mid
      }
      // 说明mid左边是升序排列的
      if(nums[left]<=nums[mid]) {
          // 判断目标值target是否位于，这个升序序列之中。
          if(target>=nums[left] && target<nums[mid]) {
              // 从中间向左边搜索
                right = mid-1
          }else{
              left = mid +1
          }
    }else {
        // mid右边是升序排列的，判断target的数值是否在mid和right之间
        if(nums[mid]<target && target <= nums[right]) {
            left = mid +1
        }else {
            right = mid-1
        }
    }
  }
  return -1
};
```

> 2022-4-28 LeetCode热题100(hot100) 每日题目第二周    &nbsp;&nbsp;&nbsp;&nbsp;周四