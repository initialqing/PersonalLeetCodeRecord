> 2022-4-20 

[LeetCode链接](https://leetcode-cn.com/problems/longest-absolute-file-path/submissions/)
####方法：栈
#### 整体思路
大致方法：用栈来维护结果字符串的长度，按照层级遍历。

1. 首先将字符串通过\n进行分割，返回分割后的数组再处理
2. 遍历数组，数组中的某个元素代表文件目录的某个层级，下边需要处理的是每个层级的绝对路径长度
3. 当文件在某个层级的时候，其现在的最长文件绝对路径包括现在层级字符串的长度加上前面所有层级字符串的长度，而字符串的长度需要用栈来维护
4. 较难处理的是层级的变换，当dir的一个子目录遍历完之后，比如此时在subsubdir1，现在的层级为3，但是subdir1已经遍历结束，下一个文件为subdir2就需要回退到第一级目录，需要改变栈维护的字符串长度。

> String.prototype.split方法
```javascript
// 传入一个要分割的字符返回分割后的数组
String.prototype.split()
```
#### 代码实现
```javascript
/**
 * @param {string} input
 * @return {number}
 */
const lengthLongestPath = function (input) {
        let res = 0
        let stack = []
        stack.push(0)
        let newString = input.split('\n')
        for (let i = 0; i < newString.length; i++) {
            // 确定当前文件的层级，当没有/t的时候返回-1，说明文件在0级。
            // 需要注意的是lastIndexOf
            let level = newString[i].lastIndexOf('\t') + 1
            /**
             * 较难理解的部分
             */
            while (stack.length - level > 1){
                stack.pop()
            }
            // 	\t\tsubsubdir1 这个字符串的长度为出去\之后的长度，计算length的时候需要减去层数补上1  也就是说长度为subsubdir1/ 这个/是算在字符串长度中的
            let length = stack[stack.length - 1] + (newString[i].length - level + 1)
            console.log(newString[i])
            stack.push(length)
            if (newString[i].includes('.')) {
                res = Math.max(res, length-1)
            }
        }
        return res
    };
```
